///
/// CallbackHolder.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `CallbackHolder`, backed by a C++ struct.
 */
public typealias CallbackHolder = margelo.nitro.image.CallbackHolder

public extension CallbackHolder {
  private typealias bridge = margelo.nitro.image.bridge.swift

  /**
   * Create a new instance of `CallbackHolder`.
   */
  init(callback: @escaping (() -> Void)) {
    self.init({ () -> bridge.Func_void in
      class ClosureHolder {
        let closure: (() -> Void)
        init(wrappingClosure closure: @escaping (() -> Void)) {
          self.closure = closure
        }
        func invoke() {
          self.closure()
        }
      }
    
      let closureHolder = Unmanaged.passRetained(ClosureHolder(wrappingClosure: callback)).toOpaque()
      func callClosure(closureHolder: UnsafeMutableRawPointer?) -> Void {
        let closure = Unmanaged<ClosureHolder>.fromOpaque(closureHolder!).takeUnretainedValue()
        closure.invoke()
      }
      func destroyClosure(_ closureHolder: UnsafeMutableRawPointer?) -> Void {
        Unmanaged<ClosureHolder>.fromOpaque(closureHolder!).release()
      }
    
      return bridge.create_Func_void(closureHolder, callClosure, destroyClosure)
    }())
  }

  var callback: (() -> Void) {
    @inline(__always)
    get {
      return { () -> (() -> Void) in
        let shared = bridge.share_Func_void(self.__callback)
        return { () -> Void in
          shared.pointee.call()
        }
      }()
    }
    @inline(__always)
    set {
      self.__callback = { () -> bridge.Func_void in
        class ClosureHolder {
          let closure: (() -> Void)
          init(wrappingClosure closure: @escaping (() -> Void)) {
            self.closure = closure
          }
          func invoke() {
            self.closure()
          }
        }
      
        let closureHolder = Unmanaged.passRetained(ClosureHolder(wrappingClosure: newValue)).toOpaque()
        func callClosure(closureHolder: UnsafeMutableRawPointer?) -> Void {
          let closure = Unmanaged<ClosureHolder>.fromOpaque(closureHolder!).takeUnretainedValue()
          closure.invoke()
        }
        func destroyClosure(_ closureHolder: UnsafeMutableRawPointer?) -> Void {
          Unmanaged<ClosureHolder>.fromOpaque(closureHolder!).release()
        }
      
        return bridge.create_Func_void(closureHolder, callClosure, destroyClosure)
      }()
    }
  }
}
